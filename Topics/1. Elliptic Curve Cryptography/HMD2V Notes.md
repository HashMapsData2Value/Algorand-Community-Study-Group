# HashMapsData2Value's Notes

## 15.0

The authors begin the chapter by refering to the discrete log problem, Computational Diffie-Helman, Decisional Diffie-Helman and how they play out in finite cyclic groups. 


#### Finite Cyclic Groups

A cyclic group is basically a set of elements that can be generated by a single element. That single element is called the generator and by repeatedly applying the "group operation" on the generator (or its inverse) you can get the rest. A group is finite if if it has a finite number of elements, i.e. there is a positive integer n such that the group has exactly n elements.

When we talk about groups the are either additive or multiplicative. These result in two different notations for the same thing.

The authors bring up the multiplicative group of integers modulo a sufficiently large prime p. 

Using multiplicative notation, and assuming that g is our generator, we can define the following group: \<g, g^1, g^2, ..., g^(q-1)\> where there are q number of elements. We say that the order of the group is q. If q is a large prime number p we can get some nice security properties (the group becomes "simple", it can't be decomposed into sub groups in non-trivial ways...).

In additive notation, assuming G is our generator, the group can be defined as \<G, 2G, 3G, ..., (p-1)G>. 

Because the groups have elements... we call those elements group elements. And we call the integers field elements, because they're defined over some field, e.g. positive integers up to the order. This field is sometimes denoted Z_p, and we can denote membership of this field with the ∈ symbol..

#### Discrete Log Problem

If you calculate the g^x mod p = y mod p and give someone g and y, there's no easy way to compute x (x = log_g(X)). This is what we call the discrete log problem. 

In additive notaton, with group generator G, we could represent it as x\*G mod p = X mod p. In this case, calculating x mod p = X/G mod p is difficult. 

When we say difficult, we mean that the only way a (classical) computer can figure it out is by bruteforcing various combinations. (This isn't necessarily true for quantum computers...). If the prime number is sufficiently large, finding an x that satisfies that equation will take a long time. We can say it's a "computationally intractable problem".

#### Computational Diffie-Helman (CDH) Assumption

Let's say you give someone the values g, g^a and g^b, where a and b are integers between 0 and p-1 (field elements), making g^a and g^b members of our group (group elements). It's computational intractable to compute g^(ab) with only these two. It's worth pointing out that this is different from taking g^a * g^b = g^(a+b), something that's very easy to do.

In additive notaton, if we have G, A (=a\*G) and B (=b\*G), calculating A\*B (=a\*b\*G) is intractable. And once again, this is different from calculating C = A+B = a\*G + b\*G = (a + b)\*G = c\*G = C.

Note that if we take A + B = C we are in essence doing addition on encrypted values, if we see a and b as cleartexts that have been encrypted, and A and B as their respective ciphertexts. This is sometimes called "homomorphic encryption" and is a very interesting topic we might explore in more detail in the future.

Finally, the CDH assumption will be revisited when we look at pairings.

#### Decisional Diffie-Helman (DDH) Assumption

Once again, let's say you give someone the values g, g^a, g^b, g^c and g^ab, with a, b ∈ Z_p. The DDH assumption means that it's not really possible to "distinguish" that g^ab has any kind of relation to g^a and g^b. If you present someone with g^ab and g^c and ask them to pick which one is composed of the product of g^a and g^b, it's impossible for them to decide! g^ab just looks like any other group element.

#### Okay, so how do these relate to elliptic curves?

For these assumptions to hold, i.e. that they are "difficult", if we use a "multiplicative group of integers modulo a sufficiently large prime p", the prime p has to be at least 2048 bits large for security to hold (for it to be super difficult for an attacker). This is a very big number and using such large primes is slow and costly.

If we instead take a look at elliptic curves, defining our group as elements (point) on that curve, we can get the same assumptions that DL, CDH and DDH are hard, but with much much smaller prime numbers for the same level of security.

You might be familiar with this with your SSH keys when interacting with GitHub. When generating keys you get to choose if you want to use RSA or ed25519. Ed25519 is the name of an elliptic curve, and just so happens to be the one used by Algorand for private and public keys.