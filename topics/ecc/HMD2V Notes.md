# HashMapsData2Value's Notes for the book

## 15.0

The authors begin the chapter by refering to the discrete log problem, Computational Diffie-Helman, Decisional Diffie-Helman and how they play out in finite cyclic groups. 


#### Finite Cyclic Groups

A cyclic group is basically a set of elements that can be generated by a single element. That single element is called the generator and by repeatedly applying the "group operation" on the generator (or its inverse) you can get the rest. A group is finite if if it has a finite number of elements, i.e. there is a positive integer n such that the group has exactly n elements.

When we talk about groups the are either additive or multiplicative. These result in two different notations for the same thing.

The authors bring up the multiplicative group of integers modulo a sufficiently large prime p. 

Using multiplicative notation, and assuming that g is our generator, we can define the following group: \<g, g^1, g^2, ..., g^(q-1)\> where there are q number of elements. We say that the order of the group is q. If q is a large prime number we can get some nice security properties (the group becomes "simple", it can't be decomposed into sub groups in non-trivial ways...).

In additive notation, assuming G is our generator, the group can be defined as \<G, 2G, 3G, ..., (p-1)G>. 

Because the groups have elements... we call those elements group elements. And we call the integers field elements, because they're defined over some field, e.g. positive integers up to the order. This field is sometimes denoted Z_p, and we can denote membership of this field with the ∈ symbol..

#### Discrete Log Problem

If you calculate the g^x mod p = y mod p and give someone g and y, there's no easy way to compute x (x = log_g(X)). This is what we call the discrete log problem. 

In additive notaton, with group generator G, we could represent it as x\*G mod p = X mod p. In this case, calculating x mod p = X/G mod p is difficult. 

When we say difficult, we mean that the only way a (classical) computer can figure it out is by bruteforcing various combinations. (This isn't necessarily true for quantum computers...). If the prime number is sufficiently large, finding an x that satisfies that equation will take a long time. We can say it's a "computationally intractable problem".

#### Computational Diffie-Helman (CDH) Assumption

Let's say you give someone the values g, g^a and g^b, where a and b are integers between 0 and p-1 (field elements), making g^a and g^b members of our group (group elements). It's computational intractable to compute g^(ab) with only these two. It's worth pointing out that this is different from taking g^a * g^b = g^(a+b), something that's very easy to do.

In additive notaton, if we have G, A (=a\*G) and B (=b\*G), calculating A\*B (=a\*b\*G) is intractable. And once again, this is different from calculating C = A+B = a\*G + b\*G = (a + b)\*G = c\*G = C.

The only way to calculate g^(ab) (a\*b\*G) is if you have a and g^b (b\*G) (or vice-versa with b and g^a (a\*G)). Then you can treat g^b (b\*G) as a new generator point g_b (B) and simply calculate g_b^a (a\*B).

Note that if we take A + B = C we are in essence doing addition on encrypted values, if we see a and b as cleartexts that have been encrypted, and A and B as their respective ciphertexts. This is sometimes called "homomorphic encryption" and is a very interesting topic we might explore in more detail in the future.

#### Decisional Diffie-Helman (DDH) Assumption

Once again, let's say you give someone the values g, g^a, g^b, g^c and g^ab, with a, b ∈ Z_p. The DDH assumption means that it's not really possible to "distinguish" that g^ab has any kind of relation to g^a and g^b. If you present someone with g^ab and g^c and ask them to pick which one is composed of the product of g^a and g^b, it's impossible for them to decide! g^ab just looks like any other group element.

#### Okay, so how do these relate to elliptic curves?

For these assumptions to hold, i.e. that they are "difficult", if we use a "multiplicative group of integers modulo a sufficiently large prime p", the prime p has to be at least 2048 bits large for security to hold (for it to be super difficult for an attacker). This is a very big number and using such large primes is slow and costly.

If we instead take a look at elliptic curves, defining our group as elements (point) on that curve, we can get the same assumptions that DL, CDH and DDH are hard, but with much much smaller prime numbers for the same level of security.

You might be familiar with this with your SSH keys when interacting with GitHub. When generating keys you get to choose if you want to use RSA or ed25519. Ed25519 is the name of a signature scheme that uses the Curve25519, and just so happens to be the one used by Algorand for private and public keys.


## 15.1 The group of points of an elliptic curve

How to visualize "the chord" and "tangent" methods ("point addition", "scalar multiplication")? It's easier to understand if you have some kind of visual aid:

- https://www.youtube.com/watch?v=dCvB-mhkT0w
- https://www.youtube.com/watch?v=9WjyYSn3c8I
- https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/ (gifs lower in the post)

I wouldn't spend much time memorizing how to actually perform the point addition, unless you want to try implementing it yourself.

Remember that while the curves are often presented for rationals x and y, in the cryptography context the x and y values are members of the scalar field Z_q (integers modulo order q). Thus instead of contiguous, smooth-flowing curves that extend infinitely out into to the sides, our group is defined as individual points along that curve and only for x and y limted from 0 to q.

## 15.2 Elliptic curves over finite fields

The "point at infinity" can be confusing at first. But the idea is that we are dealing with cyclic groups that "loop around" after they fall off the edge of the x or y axis. Because of this it is possible to loop around and end up in the same point you started with.

Say we have a point P, which we add to itself. P+P=2P. This is also known as taking the scalar multiplication, where 2 is the scalar. We could take a scalar k and multiply it like k\*P. At some point, since we are looping around, if you set k at just right value you'll end up back at P.

In additive notation, we can define the point at infinity (or identity element) as O such that  P + O = P. Or O such that P + (-P) = O.
In multiplicative notation, it would be like having g^a \* g^0 = g^(a+0) = g^a, g^a \* g^(-a) = g^0.

It can help to think of this point as not as a point that actually is generated, but an "artificial" point that has been added to the group to ensure there is an identity element. 

[This stackexchange page](https://crypto.stackexchange.com/questions/70507/in-elliptic-curve-what-does-the-point-at-infinity-look-like) has some good additional explanations of the point at infinity, including how using a different type of representation of the points ("projective coordinates", where the axes are wrapped around a sphere). 

## 15.3 Elliptic curve cryptography

E/F_p is an elliptic curve and E(F_p) is the group of points on the curve defined over F_p. (I.e., take your generator point and then scalar-multiply it with the fields elements in F_p).

"Abelian" group means that the operations of a group are commutative, i.e. that P+Q = Q+P, or g^a \* g^b = g^b \* g^a.

Regarding "insecure curves" - what is being said here is that the finite field for which the field elements are defined on, and the actual order of the group of elliptic points that make up the elliptic curve itself, don't necessarily have to be the same size. In fact, they shouldn't be the same size.

For Ed25519 (Algorand's signature scheme) as an example:
- Curve equation: −x^2 + y^2 = 1 − (121665/121666) * x^2 * y^2 ("Twisted Edwards curve")
- There's a base point, B. It can be represented in rational form as (x, 4/5) where x is the positive value of the square root that is set by putting in y = 4/5 in the equation. It's a rational number because Ed25519 is defined over over a Twisted Edwards curve. It can however be encoded over into a prime field with the base points then defined with integer coordinates: (15112221349535400772501151409588531511454012693041857206046113283949847762202, 46316835694926478169428394003475163141307993866256225615783033603165251855960)
- There's a prime l = 2^252 + 27742317777372353535851937790883648493 which defines the maximum scalar we can use. The x-y canvas axes on which the points are will max out with l, which will also determine how many possible secret keys the curve has (and the strength of that).
- The total number of points on the curve is however q = 2^255 - 19.

(Here we are using l but in the book they use p. Depending on your resource, p and q will be used in the exact opposite way - sigh.)

Just because the number of points on the curve are q = 2^255 - 19 (number of values that can satisfy the equation) doesn't mean that the base point B will be able to generate all of those points. In fact, there are even some [dangerous points that have very small orders](https://crypto.stackexchange.com/questions/55632/libsodium-x25519-and-ed25519-small-order-check).

#### Ed25519 Signature

Before looking at signature schemes from pairings, it can be good to look at the signature scheme used in Algorand: Ed25519. Ed25519 is an "instantiation" of the Edwards-curve Digital Signature Algorithm (EdDSA) digital signature scheme template which uses "a variant of Schnorr signature based on twisted Edwards curves". Specifically, Ed25519 uses SHA512 and Curve25519.

This stuff is covered later in the book but is relevant for our understanding of ECC so might as well bring it up now.

We have the following (additive notation):
- G <-- a point on the curve that serve as our generator (has x,y coordinates).
- l <-- a large prime number, order of the base/generator point.
- a <-- private key (field element part of the finite field, scalar value)
- A == a\*G (mod l) <-- X is our public key (point on the curve). Public value.
- h(.) <-- hash function (SHA512), accepts inputs of arbitrary size. h(W||Z) means that we are taking a hash of the bytes of W concatenated with Z.
- r <-- a randomly generated field element.
- R == r\*G (mod l) <-- R is a point on the curve.
- m <-- our message, what we want to sign off on.
So you start off with a message m you want to sign off with a such that someone can verify it with the public value A.

Start off by randomly generating r. Note that r must be truly random and different each time, or a will be leaked! (Sony Playstation 3 leaked their .
private key and got hacked making this mistake...).

Calculate s:
- s == r + h(R||A||m)\*a (mod l)
(\* is normal multiplication here.)

multiply both sides with G (\* is scalar-multiplication here):
- s\*G == r\*G + h(R||A||m)\*a\*G (mod l)
- S == R + h(R||A||m)\*A (mod l)

Now, we present σ = R||s to the world as our signature σ. R and s are both 32 bytes (since we can represent point R with only one coordinate and calculate the other one with the curve equation.). Also, once again, remember that if r is leaked an attacker can calculate a using the scalar modular inverse.

In the Algorand blockchain, A represents your address, a your private key and m e.g. the details of a transaction going from A elsewhere.

A verifier (the other participation nodes) can verify that you actually want to make this transaction (assuming you haven't been hacked) using σ=R||s. How?

Calculate:
- R + h(R||A||m)\*A (mod l) == S
- s\*G (mod l) == S'

If S == S' then the signature is valid with overwhelming probability. An adversary would've had to break the discrete log assumption to generate a valid s from S'.

What if r was known however? then:

a == (s - r)\*h(R||A||m)^(-1) (mod l)

Algorand offers the [opcode ed25519_verify](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/#ed25519verify) (and the "bare" version) for verifying ed25519 signatures in the AVM.

## 15.4 Pairing based cryptography

[Click here](https://www.youtube.com/watch?v=8WDOpzxpnTE) for Dan Boneh's presentation on pairings. Watching i twice, and taking some notes while at it, really helped me understand pairings. (Dan's intro is given by the Foundation's very own Professor Tal Rabin.)

#### DDH and Homomorphic Encryption

For points g (generator for G1) and h (generator for G2) as well as scalars a and b we can define the following equality: e(g^a, h^b) = e(g, h)^(a\*b) = e(g^b, h^a).

To some extent this clashes a little with the DDH assumption, which said that for g^a and g^b it's impossible to connect them to g^ab - unless you have access to the secrets a or b (as a\*g^b = b\*g^a = g^ab). If G1 = G2 (symmetric pairing groups) you can indeed check that e(g^a, g^b) = e(g,g)^(a\*b). But this isn't the case for G1 =/= G2.

Pairings in additive notation (using symmetric pairings), for generator G, a\*G = A and b\*G = B, would be defined as e(a\*G, b\*G) = ab\*e(G, G). This means that if we view A + B = C = (a + b)\*G = c\*G as homomorphic addition between two encrypted values a and b, we can see pairings as allowing us to access a form of homorphic multiplication between encrypted values a and b. (In multiplicative notation replace homomorphic addition with homomorphic multiplicaton, and  homomorphic multiplication with homomorphic exponentiation.)

#### Computation cost

Assume that we have G1 x G2 -> G_T for G1 =/= G2. It is generally the case that operations in G1 are the cheapest, then in G2 and finally in G_T.

This means that if we have g generating G1 and h generating G2, as well as a scalar a, it is the case that even if the following equality holds: e(g^a, h) = e(g, h^a) = e(g, h)^a, each item costs differently.

- e(g^a, h): we evaluate g^a first (operation in G1) and then the pairing.
- e(g, h^a): we evalute h^a first (operation in G2) and then the pairing.
- e(g, h)^a: we evalute the pairing first and then take it to ^a (operation in G_T)

Refer [to the AVM opcodes](https://github.com/algorand/go-algorand/pull/4924/files) to get a view of different the opcode costs, e.g. BN254g1 vs BN254g2.

Just something to keep in mind hehe.

#### Pairing Friendly Curves and Algorand

As of the time of writing the go-algorand core Algorand node software is being expanded with code from the golang software package [gnark-crypto](https://github.com/consensys/gnark-crypto/). The pairing friendly curves BN254 and BNS12-381 are being added; [Algorand commissioned an audit](https://github.com/ConsenSys/gnark-crypto/blob/master/audit_oct2022.pdf) into the parts of gnark-crypto that handle these curves.


The EVM currently has the [alt_bn128 curve](https://ethereum.github.io/execution-specs/autoapi/ethereum/crypto/index.html) available. It's [BN254 with a different name](https://eips.ethereum.org/EIPS/eip-2494).


#### The 3 Types/Cassifications of Pairings

Sometimes people will talk about "type 1, type 2, type 3" pairings. They are as follows:

- 1: G_0 = G_1 (symmetric pairing)
- 2: G_0 =! G_1 but there is an *efficiently computable* homomorphism function that maps from G_1 to G_0.
- 3: G_0 =! G_1 and there are NO *efficiently computable* homomorphisms between G_1 to G_0. 

#### Group Notations

In the book they use G_0 and G_1 but in other places (e.g. AVM docs, Wikipedia) G_1 and G_2 are used instead for the same groups. G_T is usually always G_T though, for T "target group". 

## 15.5 Signature schemes from pairings

#### Hash/Map to a point

The hash functions we are normally used to working with (SHA2, Keccak, MD5, etc) are map some arbitrary input data (bts) into a fixed length, "random", value within a range. I.e., they give you a scalar value.

There is a different type of hash function however which accepts input data and produces a point on the curve directly.

In the [EC Math PR](https://github.com/algorand/go-algorand/pull/4924/files) this upcoming AVM opcode will be called ec_map_to_g, using the Shallue-van de Woestijne (SvdW) method and Simplified Shallue-Woestijne-Ulas (SSWU) method for BN254 and BLS12-381 respectively. LibSodium (the cryptography framework written in C powering much of Algorand) implements this with Elligator2 for curve25519 (crypto_core_ed25519_from_uniform()).